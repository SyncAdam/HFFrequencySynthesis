library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

-- Output on the SDIO and SCLK of the DAC with 3.3V logic on the jumpers
entity ConfigureADC is
	port(
		signal writeConfig: in std_logic;
		signal configOK: inout std_logic;
		signal SDENB: inout std_logic;
		signal SCLK: inout std_logic;
		signal SDIO: out std_logic;
		signal CLKIN: in std_logic;
		signal CLKRECEIVED: out std_logic;
		signal writeConfigReceived: out std_logic;
		signal stateRegOut: out std_logic_vector(2 downto 0);
		signal nextStateRegOut: out std_logic_vector(2 downto 0);
		signal resetn: inout std_logic
	);
end entity;


architecture basic of ConfigureADC is

	type state_conf is (IDLE, SEND, INTER, DISCARD,	DONE);
	
	signal internalClock: std_logic := '0';

	signal dataIndex: integer := 0;
	
	signal counter: std_logic_vector(6 downto 0) := B"0000000";
	signal config: std_logic_vector(15 downto 0);
	signal waitingBuffer: unsigned(3 downto 0) := B"0000";
	signal discardBuffer: unsigned(0 downto 0) := B"0";
	signal clockDividerBuffer: std_logic_vector(3 downto 0) := std_logic_vector(to_unsigned(0, 4));
	
	signal state: state_conf := IDLE;
	signal nextState: state_conf := IDLE;
	
	signal generateClk: boolean := false;
	signal sendData: boolean := false;
	signal resetSend: boolean := false;
	signal waiting: boolean := false;
	signal discarding: boolean := false;
	signal needWait: boolean := false;
	signal waitingDone: boolean := false;
	signal discarded: boolean := false;
	signal outputClock: boolean := false;
	
begin
		
	ConfigMemory: entity work.ConfigRom(basic)
					port map(counter, config);
					
	DebugClock: process(internalClock, resetn)
	begin
		CLKRECEIVED <= internalClock;
		if(resetn = '0') then
			CLKRECEIVED <= '0';
		end if;
	end process;
	
	DebugWriteConf: process(CLKIN, writeConfig, resetn)
	begin
		writeConfigReceived <= writeConfig;
		if(resetn = '0') then
			writeConfigReceived <= '1';
		end if;
	end process;
	
	Debugger: process(state, CLKIN, resetn)
	begin
		case state is
			when IDLE =>	stateRegOut <= B"111";
								
			when SEND =>		stateRegOut <= B"101";
								
			when INTER =>		stateRegOut <= B"010";
								
			when DISCARD =>		stateRegOut <= B"110";
								
			when DONE =>			stateRegOut <= B"011";
			when others => 	stateRegOut <= B"000";
		end case;
		if(resetn = '0') then
			stateRegOut <=  B"000";
		end if;
	end process;
	
	DebuggerNext: process(nextState, CLKIN, resetn)
	begin
		case nextState is	
			when IDLE =>	nextStateRegOut <= B"111";
								
			when SEND =>		nextStateRegOut <= B"101";
								
			when INTER =>		nextStateRegOut <= B"010";
								
			when DISCARD =>		nextStateRegOut <= B"110";
								
			when DONE =>			nextStateRegOut <= B"011";
			when others => 	nextStateRegOut <= B"000";
		end case;
		if(resetn = '0') then
			nextStateRegOut <=  B"000";
		end if;
	end process;
					
	StatePicker: process(configOK, writeConfig, needWait, waitingDone, discarded, CLKIN, resetn) is
	begin
		if falling_edge(CLKIN) then
		case state is
			when IDLE =>	if(writeConfig = '0') then
									nextState <= DISCARD;
								else
									nextState <= IDLE;
								end if;
								
			when SEND =>	if(writeConfig = '0') then
									if(configOK = '1') then
										nextState <= DONE;
									else
										if(needWait) then
											nextState <= INTER;
										else										
											nextState <= SEND;
										end if;
									end if;
								else
									nextState <= IDLE;
								end if;
								
			when INTER =>	if(waitingDone = false) then
									nextState <= INTER;
								else
									nextState <= DISCARD;
								end if;
								
			when DISCARD =>	if(discarded = true) then
									nextState <= SEND;
								else
									nextState <= DISCARD;
								end if;
								
			when DONE =>	if(writeConfig = '1') then
									nextState <= IDLE;
								else
									nextState <= DONE;
								end if;
			when others => null;
		end case;
		if(resetn = '0') then
			nextState <=  IDLE;
		end if;
		end if;
	end process;
	
	StateMediator: process(nextState, CLKIN, resetn) is
	begin
		if rising_edge(CLKIN) then
		state <= nextState;
		if(resetn = '0') then
			state <= IDLE;
		end if;
		end if;
	end process;
						
	Outputs: process(state, CLKIN, resetn) is
	begin
		if rising_edge(CLKIN) then
		case state is
			when IDLE =>	SDENB <= '0';
								waiting <= false;
								outputClock <= false;
								discarding <= false;
								sendData <= false;
								
			when SEND =>	sendData <= true;
								waiting <= false;
								SDENB <= '1';
								outputClock <= true;
								discarding <= false;
								
			when DISCARD =>	outputClock <= false;
								sendData <= false;
								waiting <= false;
								SDENB <= '1';
								discarding <= true;
								
			when INTER =>	sendData <= false;
								waiting <= true;
								SDENB <= '0';
								outputClock <= false;
								discarding <= false;
								
			when DONE => 	sendData <= false;
								waiting <= false;
								SDENB <= '0';
								outputClock <= false;
								discarding <= false;
			
			when others => null;
		end case;
		if(resetn = '0') then
			sendData <= false;
			waiting <= false;
			SDENB <= '0';
			outputClock <= false;
			discarding <= false;
		end if;
		end if;
	end process;
	
	TransmitData: process(dataIndex, sendData, CLKIN, resetn) is
	begin
		if rising_edge(CLKIN) then
		if(sendData = true) then
			if(dataIndex < 7) then		-- in adress range
				SDIO <= counter(6 - dataIndex);
			elsif(dataIndex < 22) then	-- in data range
				SDIO <= config(15 + 7 - dataIndex);
			end if;
		end if;
		if(resetn = '0') then
			SDIO <= '0';
		end if;
		end if;
	end process;
	
	DataIndexIncrement: process(SDENB, internalClock, CLKIN, resetn) is
	begin
		if falling_edge(internalClock) then
		if(sendData = true) then
			if(dataIndex < 22) then
				dataIndex <= dataIndex + 1;
				needWait <= false;
					configOK <= '0';
			else
				dataIndex <= 0;
				needWait <= true;
				if(unsigned(counter) < 48) then 
					counter <= std_logic_vector(unsigned(counter) + 1);
				else
					counter <= B"0000000";
					configOK <= '1';
				end if;
			end if;
		end if;
		if(discarding) then
			needWait <= '0';
		end if;
		if(resetn = '0') then
			dataIndex <= 0;
			configOK <= '0';
			needWait <= false;
			counter <= B"0000000";
		end if;
		end if;
	end process;
		
	
	ClockGenerate: process(outputClock, internalClock, CLKIN, resetn) is
	begin
		if rising_edge(internalClock) then
		if(outputClock) then
			SCLK <= internalClock;
		else
			SCLK <= '0';
		end if;
		if(resetn = '0') then
			SCLK <= '0';
		end if;
		end if;
	end process;
	
	ClockDivide: process(CLKIN, resetn)
	begin
		if rising_edge(CLKIN) then
			clockDividerBuffer <= std_logic_vector(unsigned(clockDividerBuffer) + 1);
			
			if(clockDividerBuffer = B"1111") then
				clockDividerBuffer <= B"0000";
				internalClock <= not internalClock;
			end if;
			if(resetn = '0') then
				clockDividerBuffer <= B"0000";
				internalClock <= '0';
			end if;
		end if;
	end process;
	
	Waiter: process(internalClock, waiting, CLKIN, resetn)
	begin
		if rising_edge(CLKIN) then
		if(waiting and internalClock = '1') then
			if(waitingBuffer = 7) then
				waitingBuffer <= to_unsigned(0, 4);
				waitingDone <= true;
			else
				waitingBuffer <= waitingBuffer + 1;
				waitingDone <= false;
			end if;
		end if;
		if(resetn = '0') then
			waitingBuffer <= B"0000";
			waitingDone <= false;
		end if;
		end if;
	end process;
	
	Discarder: process(internalClock, discarding, CLKIN, resetn)
	begin
		if rising_edge(internalClock) then
		if(discardBuffer = B"1") then
			discarded <= true;
		end if;
		if(waiting) then
			discarded <= false;
			discardBuffer <= B"0";
		end if;
		if(internalClock = '1' and discarding) then
			discardBuffer <= discardBuffer + 1;
		end if;
		if(resetn = '0') then
			discarded <= false;
			discardBuffer <= B"0";
		end if;
		end if;
	end process;
				
			
end architecture;